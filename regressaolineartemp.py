# -*- coding: utf-8 -*-
"""RegressaoLinearTemp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ghwk4w7aHYWX7fXqi0LKNThR_7oP8VFE
"""

# instalação das bibliotecas
!pip install requests
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import requests

# parâmetros por hora (variáveis calculadas como precipitação a partir da hora)
parametro_hourly = "temperature_2m,relativehumidity_2m,dewpoint_2m,pressure_msl,surface_pressure,rain,cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,shortwave_radiation,direct_radiation,diffuse_radiation,direct_normal_irradiance,windspeed_10m,windspeed_100m,winddirection_10m,winddirection_100m,windgusts_10m,et0_fao_evapotranspiration,vapor_pressure_deficit,soil_temperature_0_to_7cm,soil_temperature_7_to_28cm,soil_temperature_28_to_100cm,soil_temperature_100_to_255cm,soil_moisture_0_to_7cm,soil_moisture_7_to_28cm,soil_moisture_28_to_100cm,soil_moisture_100_to_255cm"

# Definindo os parâmetros com valor instantâneo para as horas indicadas
parametros = {
    "latitude": -23.5505,
    "longitude": -46.6333,
    "hourly": parametro_hourly,
    "forecast_days": 1,
    "timezone": "America/Sao_Paulo",
    "start_date" : "2023-01-01",
    "end_date" : "2023-01-07"
}

# Realização da requisição de dados
# URL para a Historical Weather API
url = (f'https://archive-api.open-meteo.com/v1/archive?latitude={parametros["latitude"]}'
       f'&longitude={parametros["longitude"]}'
       f'&start_date={parametros["start_date"]}'
       f'&end_date={parametros["end_date"]}'
       f'&hourly={parametros["hourly"]}'
       f'&timezone={parametros["timezone"]}')

print("URL da requisição:", url)
requisicao = requests.get(url)

if requisicao.status_code == 200:
    dados = requisicao.json()
    print(f'Requisição bem sucedida: {requisicao.status_code}')
else:
    print(f'Erro na requisição: {requisicao.status_code}')

hourly_data = dados.get('hourly', {})
df = pd.DataFrame(hourly_data)

print("Exibição dos nomes dos campos:\n")
print(df.columns.tolist())
print("Exibição dos valores presentes nos campos:\n")
print(df.head())

# Renomeação dos campos do DataFrame
df.rename(columns={
    'time': 'data_hora',
    'temperature_2m': 'temperatura_2m',
    'relativehumidity_2m': 'umidade_relativa_2m',
    'dewpoint_2m': 'ponto_de_orvalho_2m',
    'pressure_msl': 'pressao_msl',
    'surface_pressure': 'pressao_superficie',
    'rain': 'chuva',
    'cloudcover': 'nublado',
    'cloudcover_low': 'nublado_baixo',
    'cloudcover_mid': 'nublado_medio',
    'cloudcover_high': 'nublado_alto',
    'shortwave_radiation': 'radiacao_solar',
    'direct_radiation': 'radiacao_solar_direta',
    'diffuse_radiation': 'radiacao_solar_difusa',
    'direct_normal_irradiance': 'radiacao_solar_normal_direta',
    'windspeed_10m': 'velocidade_vento_10m',
    'windspeed_100m': 'velocidade_vento_100m',
    'winddirection_10m': 'direcao_vento_10m',
    'winddirection_100m': 'direcao_vento_100m',
    'et0_fao_evapotranspiration': 'et0_fao_evapotranspiracao',
    'vapor_pressure_deficit': 'pressao_deficit_vapor',
    'soil_temperature_0_to_7cm': 'temperatura_solo_0_a_7cm',
    'soil_temperature_7_to_28cm': 'temperatura_solo_7_a_28cm',
    'soil_temperature_28_to_100cm': 'temperatura_solo_28_a_100cm',
    'soil_temperature_100_to_255cm': 'temperatura_solo_100_a_255cm'
}, inplace=True)

df.set_index('data_hora', inplace=True)
df.head(10)

"""# Limpeza dos dados"""

df.info()

# Descrição dos campos presentes no DataFrame
df.describe()

# Quantidade de valores diferentes em cada coluna
df.nunique()

# Contagem de nulos presentes no DataFrame
df.isnull().sum()

plt.figure(figsize=(10, 8))
sns.heatmap(df[['temperatura_2m', 'umidade_relativa_2m', 'ponto_de_orvalho_2m', 'chuva', 'velocidade_vento_10m', 'velocidade_vento_100m', 'direcao_vento_10m', 'direcao_vento_100m']].corr(),
            annot=True, cmap='coolwarm', center=0, linewidths=0.5)
plt.title("Mapa de Calor das Variáveis Meteorológicas Selecionadas")
plt.tight_layout()
plt.show()

# Importação de bibliotecas
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
import numpy as np

df['data_hora'] = pd.to_datetime(df.index)

# Criando a coluna 'dayofyear' que representa o dia do ano
df['dayofyear'] = df['data_hora'].dt.dayofyear

# Definindo variáveis preditoras e alvo
X = df[['dayofyear',
         'umidade_relativa_2m',
         'pressao_msl',
         'nublado',
         'velocidade_vento_10m',
        'radiacao_solar',
        'chuva',
        'ponto_de_orvalho_2m']]
y = df['temperatura_2m']

# Dividindo os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Treinando um modelo de regressão linear (exemplo)
model = LinearRegression()
model.fit(X_train, y_train)

# Fazendo previsões no conjunto de teste
y_pred = model.predict(X_test)

# Calculando o erro médio quadrático (MSE)
mse = np.mean((y_pred - y_test) ** 2)
print(f"Erro Quadrático Médio (MSE): {mse}")

# Certificando-se de que y_test e y_pred estão bem formatados
y_test.index = pd.to_datetime(y_test.index)  # Garantindo que o índice de y_test é datetime

# Ordenando os dados de teste e previsão
y_test_sorted = y_test.sort_index()
y_pred_sorted = pd.Series(y_pred, index=y_test.index).sort_index()

# Criando o gráfico para todas as datas
plt.figure(figsize=(12, 6))
plt.plot(y_test_sorted.index, y_test_sorted.values, label='Dados Reais', marker='o', color='blue')
plt.plot(y_pred_sorted.index, y_pred_sorted.values, label='Predição', marker='x', color= 'orange')
plt.xticks(rotation=45)  # Rotaciona as datas para melhor visualização
plt.xlabel('Data')
plt.ylabel('Temperatura Média (°C)')
plt.legend()
plt.title('Comparação entre Dados Reais e Predição de Temperatura')
plt.tight_layout()  # Ajusta o layout para não cortar as datas
plt.show()

plt.figure(figsize=(8, 6))
plt.scatter(y_test_sorted, y_pred_sorted, alpha=0.5)
plt.plot([min(y_test_sorted), max(y_test_sorted)], [min(y_test_sorted), max(y_test_sorted)], color='red', linestyle='--')
plt.xlabel('Dados Reais (Temperatura)')
plt.ylabel('Previsões (Temperatura)')
plt.title('Comparação de Dados Reais e Previsões')
plt.grid(True)
plt.show()

diferenca = y_test_sorted - y_pred_sorted
print(f"Média da Diferença: {diferenca.mean():.2f}")
print(f"Desvio Padrão da Diferença: {diferenca.std():.2f}")